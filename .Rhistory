circ_fun_res %>%
ggplot(aes(180*T/pi, sext.prop)) + geom_line(color="pink",size=3)  +
ylab("Proportion correct responses") +
theme_classic() + xlab("Stimulus period") +  ## data in target quadrant
geom_line(aes(y=oct.prop), color="red")   +    ## data in target octant
geom_line(aes(y=quad.prop), color="blue")    +    ## data in target octant
geom_line(data=circ_fun_res,aes(x=180*T/pi , y=pent.prop),size=1) +
geom_hline(yintercept = 1/6) +
geom_bin2d(data=res,aes(y = success, x = 180*T/pi)) + # counts
ylim(0.1,0.55)
dat <- list(
T       = res$T,
success = as.logical(res$success)
)
mlist <- alist(
success    ~   dbinom(1,phi),
#psi        <-  base*(1 - base - lapse)*phi ,
logit(phi) <-  4.39*(	T - exp(threshold)	)	/ ( exp (width) ),
threshold  ~   normal(-0.5,1),
width      ~   normal(-0.5,1) ,
base       ~   normal(0.167,0.05),  # Base is close to random probability
lapse      ~   gamma( 5,20)
)
mod <- ulam(
flist = mlist,
data = dat,
sample = F
)
set.seed(196)
N          <- 1000
base       <- rnorm(N,0.167,0.05)  # Base is close to random probability
lapse      <- rbeta(N,3,5)       # Lapse is wide range - should not overlap base rate
lapse      <- runif(N,0,.65)
threshold  <- rnorm(N,-1,1)    # Threshold must be > 0 and can be > 1.
width      <- rnorm(N,-1,1)    # Width must be > 0 and can be > 1.
# Varying intercept lapse
# Varying intercepts base
plot( NULL, xlim = c(-.5,2), ylim = c(0,1) ,
xlab = "Scaled stimulus strength", ylab = "Proportion correct response" )
abline (h=1/6, lty=2)
for ( i  in 1:N ) curve (
#  base[i] +
0.167 +
(1 - 0.167 -
#   base[i] -
lapse[i]) *
plogis(0++4.39*(	x - exp(threshold[i])	)	/ ( exp (width[i]) ) ),
from=-.5, to = 2, add = TRUE, col = col.alpha("black",0.1))
model.formula <- bf(success ~
base +
(1 - base - lapse) *
inv_logit( 4.39*(	T - exp(threshold)	)	/  exp(width)  ),
base      ~ 1,# + (1|individual), # guess rate has a single value
lapse     ~ 1, #+ (1|individual), # lapse rate can be different for different chicks
threshold ~ 1, #+ (1|individual), # threshold changes with all effects
width     ~ 1, #+ (1|individual), # threshold-width changes with all effects
nl = TRUE)
set.seed(196)
N          <- 1000
base       <- rnorm(N,0.167,0.05)  # Base is close to random probability
lapse      <- rbeta(N,3,5)       # Lapse is wide range - should not overlap base rate
lapse      <- runif(N,0,.65)
alpha      <- rlnorm(N,0,0.5)    # Threshold must be > 0 and can be > 1.
beta       <- rlnorm(N,0,2)    # Width must be > 0 and can be > 1.
plot( NULL, xlim = c(-.5,2.5), ylim = c(0,1) ,
xlab = "Scaled stimulus strength", ylab = "Proportion correct response" )
abline (h=1/6, lty=2)
for ( i  in 1:N ) curve (
base[i] + (1 - base[i] - lapse[i]) * plogis(alpha[i] + x*beta[i]),
from=-.5, to = 2.5, add = TRUE, col = col.alpha("black",0.1))
formula_ab <- bf(success ~
0.167 +
(1 - 0.167 - lapse) * inv_logit( alpha + beta*T) ,
# base      ~ 1,# + (1|individual), # guess rate has a single value
lapse     ~ 1, #+ (1|individual), # lapse rate can be different for different chicks
alpha     ~ 1, #+ (1|individual), # threshold changes with all effects
beta      ~ 1, #+ (1|individual), # threshold-width changes with all effects
nl = TRUE)
priors_ab  <- c(
prior(uniform(0,.65),       nlpar = "lapse"               ,lb = 0,ub = 0.65),
prior(normal(-2,2),         nlpar=  'alpha',  class = 'b'   ),
prior(lognormal(0,2),       nlpar = 'beta',   class = 'b'     )#,
)
model_ab  <- brm(formula_ab, data = res,
family = bernoulli("identity"), iter = 2000,
chains = 1, prior = priors_ab,
control = list(max_treedepth = 12,
adapt_delta=0.99))
model_ab  <- add_criterion(model_ab, c("loo","waic"))
conditional_effects(model_ab)
get_prior(model.formula,data=res)
hblb.formula <- bf(success ~
base +
(1 - base - lapse) *
inv_logit( 4.39*(	T - exp(threshold)	)	/  exp(width)  ),
base      ~ 1,# + (1|individual), # guess rate has a single value
lapse     ~ 1, #+ (1|individual), # lapse rate can be different for different chicks
threshold ~ 1, #+ (1|individual), # threshold changes with all effects
width     ~ 1, #+ (1|individual), # threshold-width changes with all effects
nl = TRUE)
hblb.priors  <- c(
prior(normal(0.167,0.05),   nlpar = "base",      lb=0,ub= 0.3),
prior(uniform(0,0.65),      nlpar = "lapse"                   ),
prior(normal(-1,1),         nlpar= 'threshold',  class = 'b'   ),
prior(normal(-1,1),         nlpar = 'width',     class = 'b'     ))
hblb.fit  <- brm(hblb.formula, data = res,
family = bernoulli("identity"), iter = 2000,
chains = 1, prior = hblb.priors,
control = list(max_treedepth = 12,
adapt_delta=0.99))
#hblb.fit  <- add_criterion(hblb.fit, c("loo","waic"))
conditional_effects(hblb.fit)
hbl.formula <- bf(success ~
0.167 +
(1 - 0.167 - lapse) *
inv_logit( 4.39*(	T - exp(threshold)	)	/  exp(width)  ),
lapse     ~ 1, #+ (1|individual), # lapse rate can be different for different chicks
threshold ~ 1, #+ (1|individual), # threshold changes with all effects
width     ~ 1, #+ (1|individual), # threshold-width changes with all effects
nl = TRUE)
hbl.priors  <- c(
prior(uniform(0,.65),       nlpar = "lapse"                     ,lb = 0,ub = 0.65),
prior(normal(-1,1),         nlpar= 'threshold',  class = 'b'   ),
prior(normal(-1,1),         nlpar = 'width',     class = 'b'     )#,
)
hbl.fit  <- brm(hbl.formula, data = res,
family = bernoulli("identity"), iter = 2000,
chains = 1, prior = hbl.priors,
control = list(max_treedepth = 12,
adapt_delta=0.99))
hbl.fit  <- add_criterion(hbl.fit, c("loo","waic"))
conditional_effects(hbl.fit)
orig.formula <- bf(success ~
base +
(1 - base - inv_logit(lapse)) *
inv_logit(4.39*(T-exp(threshold)	)	/
( exp (width) ) ),
base      ~ 1,	lapse     ~ 1, threshold ~ 1, width     ~ 1, nl = TRUE)
orig.priors  <- c(
prior(normal(0.167, 0.01),     nlpar = "base"                       ,lb = 0,ub=0.2),
prior(normal(0,0.5),           nlpar = "lapse"                      ,ub = 0.6), #logit(0.6) = 0.4
prior(normal(-2,2),             nlpar= 'threshold',  class = 'b'                     ),
prior(normal(-2,2),             nlpar = 'width',     class = 'b'                     )
)
orig_fit  <- brm(orig.formula, data = res,
family = bernoulli("identity"), iter = 5000,
chains = 1, prior = orig.priors,
control = list(max_treedepth = 12,adapt_delta=0.99))
orig_fit  <- add_criterion(orig_fit, c("loo","waic"))
conditional_effects(orig_fit)
samples <- posterior_samples(model_fit)
knitr::opts_chunk$set(echo = TRUE)
options(mc.cores = parallel::detectCores())      # run all cores
Sys.setenv(LOCAL_CPPFLAGS = '-march=native')     # for faster Stan execution
knitr::opts_chunk$set(root.dir = normalizePath(".."))  # set wd to main dir
con <- read_delim('../data/Ophicoma_contrast.txt', delim = '\t')
con$T <- round(con$target / max(con$target),2)
d2r <- function(x){ x <- x*pi/180 } # turn degrees to radians
vonMisease <- function(x){if(x > pi){x <- x-2*pi};return(x)}
vonMapease <- function(x){modify(x,vonMisease)}
con %>% mutate(H = d2r(heading)) -> con
con %>% mutate(H = unlist(vonMapease(H))) -> con # make headings in rad
con %>% mutate(success = 0) -> con
for(i in 1:length(con$H)){           ### get tote of each using one fifth of the circle
if(is.na(con$H[i]) == TRUE) {con$success[i] <- 0}
else if( con$H[i] >   pi/6) {con$success[i] <- 0}    ## pi/5 beforehand
else if( con$H[i] <= -pi/6 ){con$success[i] <- 0}  ## -pi/5 beforehand
else{    con$success[i] <- 1}  }
con$success
con.formula <- bf(success ~
base +
(1 - base - inv_logit(lapse)) *
inv_logit(0++4.39*(	Type-exp(threshold)	)	/
( exp (width) ) ),
base      ~ 1,# + (1|individual), # guess rate has a single value
lapse     ~ 1, #+ (1|individual), # lapse rate can be different for different chicks
threshold ~ 1, #+ (1|individual), # threshold changes with all effects
width     ~ 1, #+ (1|individual), # threshold-width changes with all effects
nl = TRUE)
con.priors  <- c(
prior(normal(0.167, 0.05),     nlpar = "base"                        ,lb = 0,ub=0.3),
prior(normal(0.1,0.2),         nlpar = "lapse"                           ,ub = 0.65),
prior(normal(1,1),             nlpar= 'threshold',  class = 'b'   ),
prior(normal(1,1),             nlpar = 'width',     class = 'b'     )#,
)
con.fit  <- brm(model.formula, data = con,
family = bernoulli("identity"), iter = 5000,
chains = 4, prior = model.priors,
control = list(max_treedepth = 12,adapt_delta=0.99))
con.priors  <- c(
prior(normal(0.167, 0.05),     nlpar = "base"                        ,lb = 0,ub=0.3),
prior(normal(0.1,0.2),         nlpar = "lapse"                           ,ub = 0.65),
prior(normal(1,1),             nlpar= 'threshold',  class = 'b'   ),
prior(normal(1,1),             nlpar = 'width',     class = 'b'     )#,
)
con.fit  <- brm(con.formula, data = con,
family = bernoulli("identity"), iter = 5000,
chains = 4, prior = con.priors,
control = list(max_treedepth = 12,adapt_delta=0.99))
con.formula <- bf(success ~
base +
(1 - base - inv_logit(lapse)) *
inv_logit(0++4.39*(	contrast -exp(threshold)	)	/
( exp (width) ) ),
base      ~ 1,# + (1|individual), # guess rate has a single value
lapse     ~ 1, #+ (1|individual), # lapse rate can be different for different chicks
threshold ~ 1, #+ (1|individual), # threshold changes with all effects
width     ~ 1, #+ (1|individual), # threshold-width changes with all effects
nl = TRUE)
get_prior(con.formula,data=con)
con.priors  <- c(
prior(normal(0.167, 0.05),     nlpar = "base"                        ,lb = 0,ub=0.3),
prior(normal(0.1,0.2),         nlpar = "lapse"                           ,ub = 0.65),
prior(normal(1,1),             nlpar= 'threshold',  class = 'b'   ),
prior(normal(1,1),             nlpar = 'width',     class = 'b'     )#,
)
con.fit  <- brm(con.formula, data = con,
family = bernoulli("identity"), iter = 5000,
chains = 4, prior = con.priors,
control = list(max_treedepth = 12,adapt_delta=0.99))
con.fit  <- add_criterion(con.fit, c("loo","waic"))
conditional_effects(con.fit)
con.priors  <- c(
prior(normal(0.167, 0.05),     nlpar = "base"                        ,lb = 0,ub=0.3),
prior(normal(0.1,0.2),         nlpar = "lapse"                           ,ub = 0.65),
prior(normal(-1,1),             nlpar= 'threshold',  class = 'b'   ),
prior(normal(-1,1),             nlpar = 'width',     class = 'b'     )#,
)
con.fit  <- brm(con.formula, data = con,
family = bernoulli("identity"), iter = 5000,
chains = 4, prior = con.priors,
control = list(max_treedepth = 12,adapt_delta=0.99))
con.fit  <- add_criterion(con.fit, c("loo","waic"))
conditional_effects(con.fit)
knitr::opts_chunk$set(echo = TRUE)
options(mc.cores = parallel::detectCores())  # run all cores
Sys.setenv(LOCAL_CPPFLAGS = '-march=native') # for faster Stan execution
conditional_effects(orig_fit)
knitr::opts_chunk$set(echo = TRUE)
options(mc.cores = parallel::detectCores())      # run all cores
Sys.setenv(LOCAL_CPPFLAGS = '-march=native')     # for faster Stan execution
con$T <- round(con$target / max(con$target),2)
d2r <- function(x){ x <- x*pi/180 } # turn degrees to radians
vonMisease <- function(x){if(x > pi){x <- x-2*pi};return(x)}
vonMapease <- function(x){modify(x,vonMisease)}
con %>% mutate(H = d2r(heading)) -> con
con %>% mutate(H = unlist(vonMapease(H))) -> con # make headings in rad
con$Cc  <- as.factor(con$contrast))
con$T <- round(con$target / max(con$target),2)
d2r <- function(x){ x <- x*pi/180 } # turn degrees to radians
vonMisease <- function(x){if(x > pi){x <- x-2*pi};return(x)}
vonMapease <- function(x){modify(x,vonMisease)}
con %>% mutate(H = d2r(heading)) -> con
con %>% mutate(H = unlist(vonMapease(H))) -> con # make headings in rad
con$Cc  <- as.factor(con$contrast)
con %>% mutate(success = 0) -> con
for(i in 1:length(con$heading)){           ### get tote of each using one fifth of the circle
if(is.na(con$heading[i]) == TRUE) {con$success[i] <- 0}
else if( con$heading[i] >   pi/6) {con$success[i] <- 0}    ## pi/5 beforehand
else if( con$heading[i] <= -pi/6 ){con$success[i] <- 0}  ## -pi/5 beforehand
else{    con$success[i] <- 1}  }
cat.1 <- bf(success ~ Cc, family = bernoulli(link="logit"))
get_prior(cat.1,data=res)
cat.1 <- bf(success ~ Cc, family = bernoulli(link="logit"))
get_prior(cat.1,data=con)
cat.prior  <- c(
prior(normal(0,1),   class = "Intercept"),
prior(normal(0,1),   class = 'b'     )
)
cat.1.fit  <- brm(cat.1, data = con,
family = bernoulli("logit"), iter = 2000,
chains = 4, prior = cat.prior)#,
#         control = list(max_treedepth = 12,
#                         adapt_delta=0.99))
conditional_effects(cat.1.fit)
con.priors  <- c(
prior(normal(0.167, 0.05),     nlpar = "base"                        ,lb = 0,ub=0.3),
prior(normal(0.1,0.2),         nlpar = "lapse"                           ,ub = 0.65),
prior(normal(1,1),             nlpar= 'threshold',  class = 'b'   ),
prior(normal(1,1),             nlpar = 'width',     class = 'b'     )#,
)
con.fit  <- brm(con.formula, data = con,
family = bernoulli("identity"), iter = 5000,
chains = 4, prior = con.priors,
control = list(max_treedepth = 12,adapt_delta=0.99))
con.fit  <- add_criterion(con.fit, c("loo","waic"))
conditional_effects(con.fit)
cat.1 <- bf(success ~ Tc, family = bernoulli(link="logit"))
cat.prior  <- c(
prior(normal(0,1),   class = "Intercept"),
prior(normal(0,1),   class = 'b'     )
)
cat.1.fit  <- brm(cat.1, data = res,
family = bernoulli("logit"), iter = 2000,
chains = 4, prior = cat.prior)
orig.formula <- bf(success ~
base +
(1 - base - inv_logit(lapse)) *
inv_logit(4.39*(T-exp(threshold)	)	/
( exp (width) ) ),
base      ~ 1,	lapse     ~ 1, threshold ~ 1, width     ~ 1, nl = TRUE)
orig.priors  <- c(
prior(normal(0.167, 0.01),     nlpar = "base"                       ,lb = 0,ub=0.2),
prior(normal(0,0.5),           nlpar = "lapse"                      ,ub = 0.65), #logit(0.6) = 0.4
prior(normal(-2,2),             nlpar= 'threshold',  class = 'b'                     ),
prior(normal(-2,2),             nlpar = 'width',     class = 'b'                     )
)
orig_fit  <- brm(orig.formula, data = res,
family = bernoulli("identity"), iter = 5000,
chains = 1, prior = orig.priors,
control = list(max_treedepth = 12,adapt_delta=0.999))
knitr::opts_chunk$set(echo = TRUE)
options(mc.cores = parallel::detectCores())  # run all cores
Sys.setenv(LOCAL_CPPFLAGS = '-march=native') # for faster Stan execution
library('magrittr')
library('readr')
library('dplyr')
library('reshape2')
library('tibble')
library('purrr')
library('circular')
library('ggplot2')
rstan::rstan_options(auto_write = TRUE)
library('rethinking')
library('brms')
knitr::opts_chunk$set(root.dir = normalizePath(".."))  # set wd to main dir
res <- read_delim('../data/O_wendtii_2019.txt', delim = '\t')
res %>% filter(contrast %in% c( 0,1)) -> res
res$T <- round(res$target / max(res$target),2)
d2r <- function(x){ x <- x*pi/180 } # turn degrees to radians
vonMisease <- function(x){if(x > pi){x <- x-2*pi};return(x)}
vonMapease <- function(x){modify(x,vonMisease)}
res %>% mutate(H = d2r(heading)) -> res
res %>% mutate(H = unlist(vonMapease(H))) -> res # make headings in rad
res %>% mutate(success = 0) -> res
for(i in 1:length(res$H)){           ### get tote of each using one fifth of the circle
if(is.na(res$H[i]) == TRUE) {res$success[i] <- 0}
else if( res$H[i] >   pi/6) {res$success[i] <- 0}    ## pi/5 beforehand
else if( res$H[i] <= -pi/6 ){res$success[i] <- 0}  ## -pi/5 beforehand
else{    res$success[i] <- 1}  }
source('Cplot2_rad.R')
#Type.prop <- vector()
par(mfrow = c(2,ceiling( nlevels(as.factor(res$T)) /2)));
par(mar = c(0.5, 0.5, 0.5, 0.5) + 0.1) # bottom, left, top, right
j = 1;
for(i in levels(as.factor(res$T)) ){
rad_plot(res$H[res$T==i],0.06)#,
#Type.prop[j] <- sum(res$success[res$T==i])/length(res$success[res$T==i])
j <- j + 1  }
res %>% as_tibble %>%                 # dataframe name
mutate(in.quad = ifelse(abs(H) < pi/4, 1, 0)) %>% # for data in radians -pi to pi
mutate(in.pent = ifelse(abs(H) < pi/5, 1, 0)) %>% # for data in radians -pi to pi
mutate(in.sext = ifelse(abs(H) < pi/6, 1, 0)) %>% # for data in radians -pi to pi
mutate(in.oct  = ifelse(abs(H) < pi/8, 1, 0)) %>% # for data in radians -pi to pi
group_by(T) %>%                # condition name
summarize(target = round(T * 180 / pi)[1],
n_obs = n(),
mu    = round(180*mean.circular(H)/pi,0),
lo.ci = round(180*mle.vonmises.bootstrap.ci(H)$mu.ci[1]/pi),
hi.ci = round(180*mle.vonmises.bootstrap.ci(H)$mu.ci[2]/pi),
rho = round(rho.circular(H),2),
kappa = unlist(mle.vonmises(H)[3]),
v.stat =unlist(rayleigh.test(H,mu=0)[1]),
v.p= unlist(rayleigh.test(H,mu=0)[2]),
rayl.stat=unlist(rayleigh.test(H)[1]),
rayl.p= unlist(rayleigh.test(H)[2]),
c.mean = unlist(mean.circular(H)[1]),
quad.prop = sum(in.quad)/length(in.quad),
pent.prop = sum(in.pent)/length(in.pent),
sext.prop = sum(in.sext)/length(in.sext),
oct.prop = sum(in.oct)/length(in.oct),
binom.p6 = unlist(
binom.test(sum(in.sext),length(in.sext),
p=1/6,alternative = "greater")[3]),
binom.p8 = unlist(
binom.test(sum(in.oct),length(in.oct),
p=1/8,alternative = "greater")[3]),
binom.p5 = unlist(
binom.test(sum(in.pent),length(in.pent),
p=1/5,alternative = "greater")[3])) -> circ_fun_res
## output dataframe
circ_fun_res
circ_fun_res %>%
ggplot(aes(180*T/pi, sext.prop)) + geom_line(color="pink",size=3)  +
ylab("Proportion correct responses") +
theme_classic() + xlab("Stimulus period") +  ## data in target quadrant
geom_line(aes(y=oct.prop), color="red")   +    ## data in target octant
geom_line(aes(y=quad.prop), color="blue")    +    ## data in target octant
geom_line(data=circ_fun_res,aes(x=180*T/pi , y=pent.prop),size=1) +
geom_hline(yintercept = 1/6) +
geom_bin2d(data=res,aes(y = success, x = 180*T/pi)) + # counts
ylim(0.1,0.55)
dat <- list(
T       = res$T,
success = as.logical(res$success)
)
mlist <- alist(
success    ~   dbinom(1,phi),
#psi        <-  base*(1 - base - lapse)*phi ,
logit(phi) <-  4.39*(	T - exp(threshold)	)	/ ( exp (width) ),
threshold  ~   normal(-0.5,1),
width      ~   normal(-0.5,1) ,
base       ~   normal(0.167,0.05),  # Base is close to random probability
lapse      ~   gamma( 5,20)
)
mod <- ulam(
flist = mlist,
data = dat,
sample = F
)
set.seed(196)
N          <- 1000
base       <- rnorm(N,0.167,0.05)  # Base is close to random probability
lapse      <- rbeta(N,3,5)       # Lapse is wide range - should not overlap base rate
lapse      <- runif(N,0,.65)
threshold  <- rnorm(N,-1,1)    # Threshold must be > 0 and can be > 1.
width      <- rnorm(N,-1,1)    # Width must be > 0 and can be > 1.
# Varying intercept lapse
# Varying intercepts base
plot( NULL, xlim = c(-.5,2), ylim = c(0,1) ,
xlab = "Scaled stimulus strength", ylab = "Proportion correct response" )
abline (h=1/6, lty=2)
for ( i  in 1:N ) curve (
#  base[i] +
0.167 +
(1 - 0.167 -
#   base[i] -
lapse[i]) *
plogis(0++4.39*(	x - exp(threshold[i])	)	/ ( exp (width[i]) ) ),
from=-.5, to = 2, add = TRUE, col = col.alpha("black",0.1))
get_prior(model.formula,data=res)
hblb.formula <- bf(success ~
base +
(1 - base - lapse) *
inv_logit( 4.39*(	T - exp(threshold)	)	/  exp(width)  ),
base      ~ 1,# + (1|individual), # guess rate has a single value
lapse     ~ 1, #+ (1|individual), # lapse rate can be different for different chicks
threshold ~ 1, #+ (1|individual), # threshold changes with all effects
width     ~ 1, #+ (1|individual), # threshold-width changes with all effects
nl = TRUE)
hblb.priors  <- c(
prior(normal(0.167,0.05),   nlpar = "base",      lb=0,ub= 0.3),
prior(uniform(0,0.65),      nlpar = "lapse"                   ),
prior(normal(-1,1),         nlpar= 'threshold',  class = 'b'   ),
prior(normal(-1,1),         nlpar = 'width',     class = 'b'     ))
hblb.fit  <- brm(hblb.formula, data = res,
family = bernoulli("identity"), iter = 2000,
chains = 1, prior = hblb.priors,
control = list(max_treedepth = 12,
adapt_delta=0.99))
hblb.formula <- bf(success ~
base +
(1 - base - lapse) *
inv_logit( 4.39*(	T - exp(threshold)	)	/  exp(width)  ),
base      ~ 1,# + (1|individual), # guess rate has a single value
lapse     ~ 1, #+ (1|individual), # lapse rate can be different for different chicks
threshold ~ 1, #+ (1|individual), # threshold changes with all effects
width     ~ 1, #+ (1|individual), # threshold-width changes with all effects
nl = TRUE)
hblb.priors  <- c(
prior(normal(0.167,0.05),   nlpar = "base",      lb=0,ub= 0.3),
prior(uniform(0,0.65),      nlpar = "lapse"                   ),
prior(normal(-1,1),         nlpar= 'threshold',  class = 'b'   ),
prior(normal(-1,1),         nlpar = 'width',     class = 'b'     ))
hblb.fit  <- brm(hblb.formula, data = res,
family = bernoulli("identity"), iter = 2000,
chains = 1, prior = hblb.priors,
control = list(max_treedepth = 12,
adapt_delta=0.99))
#hblb.fit  <- add_criterion(hblb.fit, c("loo","waic"))
hblb.formula <- bf(success ~
base +
(1 - base - lapse) *
inv_logit( 4.39*(	T - exp(threshold)	)	/  exp(width)  ),
base      ~ 1,# + (1|individual), # guess rate has a single value
lapse     ~ 1, #+ (1|individual), # lapse rate can be different for different chicks
threshold ~ 1, #+ (1|individual), # threshold changes with all effects
width     ~ 1, #+ (1|individual), # threshold-width changes with all effects
nl = TRUE)
hblb.priors  <- c(
prior(normal(0.167,0.05),   nlpar = "base",      lb=0,ub= 0.3),
prior(beta(3,5),      nlpar = "lapse"             ,lb=0,ub=0.69      ),
prior(normal(-1,1),         nlpar= 'threshold',  class = 'b'   ),
prior(normal(-1,1),         nlpar = 'width',     class = 'b'     ))
hblb.fit  <- brm(hblb.formula, data = res,
family = bernoulli("identity"), iter = 2000,
chains = 1, prior = hblb.priors,
control = list(max_treedepth = 12,
adapt_delta=0.99))
#hblb.fit  <- add_criterion(hblb.fit, c("loo","waic"))
orig_fit
hblb.fit
hblb.formula <- bf(success ~
base +
(1 - base - lapse) *
inv_logit( 4.39*(	T - exp(threshold)	)	/  exp(width)  ),
base      ~ 1,# + (1|individual), # guess rate has a single value
lapse     ~ 1, #+ (1|individual), # lapse rate can be different for different chicks
threshold ~ 1, #+ (1|individual), # threshold changes with all effects
width     ~ 1, #+ (1|individual), # threshold-width changes with all effects
nl = TRUE)
hblb.priors  <- c(
prior(normal(0.167,0.05),   nlpar = "base",      lb=0,ub= 0.3),
prior(beta(3,5),      nlpar = "lapse"             ,lb=0,ub=0.69      ),
prior(normal(-1,1),         nlpar= 'threshold',  class = 'b'   ),
prior(normal(-1,1),         nlpar = 'width',     class = 'b'     ))
hblb.fit  <- brm(hblb.formula, data = res,
family = bernoulli("identity"), iter = 2000,
chains = 1, prior = hblb.priors,
control = list(max_treedepth = 12,
adapt_delta=0.9999))
#hblb.fit  <- add_criterion(hblb.fit, c("loo","waic"))
