pnorm(1.96)
dnorm(1.96)
dnorm(1.96)
help(dnorm)
pnorm(1.9)
pnorm(1.8)
pnorm(0)
pnorm(-1.96)
pnorm(1.96)
hist(plogis(rnorm(1000,0,0.1)))
hist(plogis(rnorm(1000,0,0.2)))
hist(plogis(rnorm(1000,0,0.3)))
hist(plogis(rnorm(1000,0,0.5)))
hist(plogis(rnorm(1000,-0.2,0.5)))
hist(plogis(rnorm(1000,-1,0.5)))
hist(plogis(rnorm(1000,-1,1)))
hist(plogis(rnorm(1000,-1,0.7)))
hist(plogis(rnorm(1000,-0.5,0.7)))
hist(rbeta(1000,3,5))
hist(rbeta(1000,3,5))
hist(rbeta(1000,3,5))
hist(plogis(rnorm(1000,-0.5,0.7)))
knitr::opts_chunk$set(echo = TRUE)
options(mc.cores = parallel::detectCores())  # run all cores
Sys.setenv(LOCAL_CPPFLAGS = '-march=native') # for faster Stan execution
library('magrittr')
library('readr')
library('dplyr')
library('purrr')
library('tibble')
library('circular')
library('ggplot2')
library('reshape2')
library('circular')
library('bayesplot')
rstan::rstan_options(auto_write = TRUE)
library('rethinking')
library('brms')
knitr::opts_chunk$set(root.dir = normalizePath(".."))  # set wd to main dir
full <- read_delim('../data/O_wendtii_2019.txt', delim = '\t')
full %>% filter(contrast %in% c( 0,1)) -> res
full$T <- round(full$target / max(full$target),2)
d2r <- function(x){ x <- x*pi/180 } # turn degrees to radians
vonMisease <- function(x){if(x > pi){x <- x-2*pi};return(x)}
vonMapease <- function(x){modify(x,vonMisease)}
full %>% mutate(H = d2r(heading)) -> full
full %>% mutate(H = unlist(vonMapease(H))) -> full # make headings in rad
full %>%
ggplot(aes(target,contrast)) + geom_count()
full %>% mutate(success = 0) -> full
for(i in 1:length(full$heading)){           ### get tote of each using one fifth of the circle
if(is.na(full$heading[i]) == TRUE) {full$success[i] <- 0}
else if( full$heading[i] >   pi/6) {full$success[i] <- 0}    ## pi/5 beforehand
else if( full$heading[i] <= -pi/6 ){full$success[i] <- 0}  ## -pi/5 beforehand
else{    full$success[i] <- 1}  }
full %>% filter(contrast %in% c( 0,1)) -> res
full %>% filter(target   %in% c(60,0)) -> con
full %>% as_tibble %>%                 # dataframe name
mutate(in.quad = ifelse(abs(H) < pi/4, 1, 0)) %>% # for data in radians -pi to pi
mutate(in.pent = ifelse(abs(H) < pi/5, 1, 0)) %>% # for data in radians -pi to pi
mutate(in.sext = ifelse(abs(H) < pi/6, 1, 0)) %>% # for data in radians -pi to pi
mutate(in.oct  = ifelse(abs(H) < pi/8, 1, 0)) %>% # for data in radians -pi to pi
group_by(T,contrast) %>%                # condition name
summarize(target = round(T * 180 / pi)[1],
n_obs = n(),
mu    = round(180*mean.circular(H)/pi,0),
lo.ci = round(180*mle.vonmises.bootstrap.ci(H)$mu.ci[1]/pi),
hi.ci = round(180*mle.vonmises.bootstrap.ci(H)$mu.ci[2]/pi),
rho = round(rho.circular(H),2),
kappa = unlist(mle.vonmises(H)[3]),
v.stat =unlist(rayleigh.test(H,mu=0)[1]),
v.p= unlist(rayleigh.test(H,mu=0)[2]),
rayl.stat=unlist(rayleigh.test(H)[1]),
rayl.p= unlist(rayleigh.test(H)[2]),
c.mean = unlist(mean.circular(H)[1]),
quad.prop = sum(in.quad)/length(in.quad),
pent.prop = sum(in.pent)/length(in.pent),
sext.prop = sum(in.sext)/length(in.sext),
oct.prop = sum(in.oct)/length(in.oct),
binom.p6 = unlist(
binom.test(sum(in.sext),length(in.sext),
p=1/6,alternative = "greater")[3]),
binom.p8 = unlist(
binom.test(sum(in.oct),length(in.oct),
p=1/8,alternative = "greater")[3]),
binom.p5 = unlist(
binom.test(sum(in.pent),length(in.pent),
p=1/5,alternative = "greater")[3])) -> circ_fun_facts
## output dataframe
circ_fun_facts
res$T <- round(res$target / max(res$target),2)
d2r <- function(x){ x <- x*pi/180 } # turn degrees to radians
vonMisease <- function(x){if(x > pi){x <- x-2*pi};return(x)}
vonMapease <- function(x){modify(x,vonMisease)}
res %>% mutate(H = d2r(heading)) -> res
res %>% mutate(H = unlist(vonMapease(H))) -> res # make headings in rad
res %>% mutate(success = 0) -> res
for(i in 1:length(res$H)){           ### get tote of each using one fifth of the circle
if(is.na(res$H[i]) == TRUE) {res$success[i] <- 0}
else if( res$H[i] >   pi/6) {res$success[i] <- 0}    ## pi/5 beforehand
else if( res$H[i] <= -pi/6 ){res$success[i] <- 0}  ## -pi/5 beforehand
else{    res$success[i] <- 1}  }
source('Cplot2_rad.R')
par(mfrow = c(2,ceiling( nlevels(as.factor(res$T)) /2)));
par(mar = c(0.5, 0.5, 0.5, 0.5) + 0.1) # bottom, left, top, right
for(i in levels(as.factor(res$T)) ){
rad_plot(res$H[res$T==i],0.06)
}
res %>% as_tibble %>%                 # dataframe name
mutate(in.quad = ifelse(abs(H) < pi/4, 1, 0)) %>% # for data in radians -pi to pi
mutate(in.pent = ifelse(abs(H) < pi/5, 1, 0)) %>% # for data in radians -pi to pi
mutate(in.sext = ifelse(abs(H) < pi/6, 1, 0)) %>% # for data in radians -pi to pi
mutate(in.oct  = ifelse(abs(H) < pi/8, 1, 0)) %>% # for data in radians -pi to pi
group_by(T) %>%                # condition name
summarize(target = round(T * 180 / pi)[1],
n_obs = n(),
mu    = round(180*mean.circular(H)/pi,0),
lo.ci = round(180*mle.vonmises.bootstrap.ci(H)$mu.ci[1]/pi),
hi.ci = round(180*mle.vonmises.bootstrap.ci(H)$mu.ci[2]/pi),
rho = round(rho.circular(H),2),
kappa = unlist(mle.vonmises(H)[3]),
v.stat =unlist(rayleigh.test(H,mu=0)[1]),
v.p= unlist(rayleigh.test(H,mu=0)[2]),
rayl.stat=unlist(rayleigh.test(H)[1]),
rayl.p= unlist(rayleigh.test(H)[2]),
c.mean = unlist(mean.circular(H)[1]),
quad.prop = sum(in.quad)/length(in.quad),
pent.prop = sum(in.pent)/length(in.pent),
sext.prop = sum(in.sext)/length(in.sext),
oct.prop = sum(in.oct)/length(in.oct),
binom.p6 = unlist(
binom.test(sum(in.sext),length(in.sext),
p=1/6,alternative = "greater")[3]),
binom.p8 = unlist(
binom.test(sum(in.oct),length(in.oct),
p=1/8,alternative = "greater")[3]),
binom.p5 = unlist(
binom.test(sum(in.pent),length(in.pent),
p=1/5,alternative = "greater")[3])) -> circ_fun_res
## output dataframe
circ_fun_res
circ_fun_res %>%
ggplot(aes(180*T/pi, sext.prop)) + geom_line(color="pink",size=3)  +
ylab("Proportion correct responses") +
theme_classic() + xlab("Stimulus period") +  ## data in target quadrant
geom_line(aes(y=oct.prop), color="red")   +    ## data in target octant
geom_line(aes(y=quad.prop), color="blue")    +    ## data in target octant
geom_line(data=circ_fun_res,aes(x=180*T/pi , y=pent.prop),size=1) +
geom_hline(yintercept = 1/6) +
geom_bin2d(data=res,aes(y = success, x = 180*T/pi)) + # counts
ylim(0.1,0.55)
set.seed(196)
N          <- 1000
base       <- rnorm(N,0.167,0.05)  # Base is close to random probability
lapse      <- rbeta(N,3,5)       # Lapse is wide range - should not overlap base rate
lapse      <- runif(N,0,.65)
threshold  <- rgamma(N,2,2)    # Threshold must be > 0 and can be > 1.
width      <- rgamma(N,2,2)    # Width must be > 0 and can be > 1.
# Varying intercept lapse
# Varying intercepts base
plot( NULL, xlim = c(-.5,2.5), ylim = c(0,1) ,
xlab = "Scaled stimulus strength", ylab = "Proportion correct response" )
abline (h=1/6, lty=2)
for ( i  in 1:N ) curve (
base[i] +
(1 - base[i] - lapse[i]) *
plogis(4.39*(	x - exp(threshold[i])	)	/ ( exp (width[i]) ) ),
from=-.5, to = 2.5, add = TRUE, col = col.alpha("black",0.1))
res.empty.formula <- bf(success ~
base +
(1 - base - lapse) *
inv_logit( 4.39*(	1 - threshold)	/  width  ),
base      ~ 1,# + (1|individual), # guess rate has a single value
lapse     ~ 1, #+ (1|individual), # lapse rate can be different for different chicks
threshold ~ 1, #+ (1|individual), # threshold changes with all effects
width     ~ 1, #+ (1|individual), # threshold-width changes with all effects
nl = TRUE)
res.psych.priors  <- c(
prior(normal(0.167,0.05),   nlpar = "base",        lb=0,ub= 0.25),
prior(beta(3,5),      nlpar = "lapse"             ,lb=0,ub= 0.74      ),
prior(gamma(2,2),         nlpar= 'threshold',  class = 'b'   ),
prior(gamma(2,2),         nlpar = 'width',     class = 'b'     ))
res.empty.fit  <- brm(res.empty.formula, data = res, family = bernoulli("identity"), iter = 5000,
chains = 4, prior = res.psych.priors, control = list(adapt_delta=0.9999))
res.empty.fit <- add_criterion(res.empty.fit, c("loo","waic"))
res.psych.formula <- bf(success ~
base +
(1 - base - lapse) *
inv_logit( 4.39*(	T - threshold	)	/  width  ),
base      ~ 1,# + (1|individual), # guess rate has a single value
lapse     ~ 1, #+ (1|individual), # lapse rate can be different for different chicks
threshold ~ 1, #+ (1|individual), # threshold changes with all effects
width     ~ 1, #+ (1|individual), # threshold-width changes with all effects
nl = TRUE)
res.psych.priors  <- c(
prior(normal(0.167,0.05),   nlpar = "base",        lb=0,ub= 0.25),
prior(beta(3,5),            nlpar = "lapse"             ,lb=0,ub= 0.74      ),
prior(rgamma(2,2),          nlpar= 'threshold',  class = 'b'   ),
prior(rgamma(2,2),          nlpar = 'width',     class = 'b'     ))
res.psych.fit  <- brm(res.psych.formula, data = res,
family = bernoulli("identity"), iter = 2500,
chains = 4, prior = res.psych.priors,
control = list(max_treedepth = 12,
adapt_delta=0.9999))
res.psych.formula <- bf(success ~
base +
(1 - base - lapse) *
inv_logit( 4.39*(	T - threshold	)	/  width  ),
base      ~ 1,# + (1|individual), # guess rate has a single value
lapse     ~ 1, #+ (1|individual), # lapse rate can be different for different chicks
threshold ~ 1, #+ (1|individual), # threshold changes with all effects
width     ~ 1, #+ (1|individual), # threshold-width changes with all effects
nl = TRUE)
res.psych.priors  <- c(
prior(normal(0.167,0.05),   nlpar = "base",        lb=0,ub= 0.25),
prior(beta(3,5),            nlpar = "lapse"             ,lb=0,ub= 0.74      ),
prior(gamma(2,2),          nlpar= 'threshold',  class = 'b'   ),
prior(gamma(2,2),          nlpar = 'width',     class = 'b'     ))
res.psych.fit  <- brm(res.psych.formula, data = res,
family = bernoulli("identity"), iter = 2500,
chains = 4, prior = res.psych.priors,
control = list(max_treedepth = 12,
adapt_delta=0.9999))
res.psych.fit  <- add_criterion(res.psych.fit, c("loo","waic"))
set.seed(196)
N          <- 1000
base       <- rnorm(N,0.167,0.05)  # Base is close to random probability
lapse      <- rbeta(N,3,5)       # Lapse is wide range - should not overlap base rate
#lapse      <- runif(N,0,.65)
threshold  <- rgamma(N,2,2)    # Threshold must be > 0 and can be > 1.
width      <- rgamma(N,2,2)    # Width must be > 0 and can be > 1.
# Varying intercept lapse
# Varying intercepts base
plot( NULL, xlim = c(-.5,2.5), ylim = c(0,1) ,
xlab = "Scaled stimulus strength", ylab = "Proportion correct response" )
abline (h=1/6, lty=2)
for ( i  in 1:N ) curve (
base[i] +
(1 - base[i] - lapse[i]) *
plogis(4.39*(	x - exp(threshold[i])	)	/ ( exp (width[i]) ) ),
from=-.5, to = 2.5, add = TRUE, col = col.alpha("black",0.1))
hist(rgamma(1000,2,2))
hist(rgamma(1000,2,1.5))
set.seed(196)
N          <- 1000
base       <- rnorm(N,0.167,0.05)  # Base is close to random probability
lapse      <- rbeta(N,3,5)       # Lapse is wide range - should not overlap base rate
#lapse      <- runif(N,0,.65)
threshold  <- rgamma(N,2,1.5)    # Threshold must be > 0 and can be > 1.
width      <- rgamma(N,2,1.5)    # Width must be > 0 and can be > 1.
# Varying intercept lapse
# Varying intercepts base
plot( NULL, xlim = c(-.5,2.5), ylim = c(0,1) ,
xlab = "Scaled stimulus strength", ylab = "Proportion correct response" )
abline (h=1/6, lty=2)
for ( i  in 1:N ) curve (
base[i] +
(1 - base[i] - lapse[i]) *
plogis(4.39*(	x - exp(threshold[i])	)	/ ( exp (width[i]) ) ),
from=-.5, to = 2.5, add = TRUE, col = col.alpha("black",0.1))
set.seed(196)
N          <- 1000
base       <- rnorm(N,0.167,0.05)  # Base is close to random probability
lapse      <- rbeta(N,3,5)       # Lapse is wide range - should not overlap base rate
#lapse      <- runif(N,0,.65)
threshold  <- rgamma(N,2,1.5)    # Threshold must be > 0 and can be > 1.
width      <- rgamma(N,2,1.5)    # Width must be > 0 and can be > 1.
# Varying intercept lapse
# Varying intercepts base
plot( NULL, xlim = c(-.5,2.5), ylim = c(0,1) ,
xlab = "Scaled stimulus strength", ylab = "Proportion correct response" )
abline (h=1/6, lty=2)
for ( i  in 1:N ) curve (
base[i] +
(1 - base[i] - lapse[i]) *
plogis(4.39*(	x - exp(threshold[i])	)	/ ( exp (width[i]) ) ),
from=-.5, to = 2.5, add = TRUE, col = col.alpha("black",0.1))
set.seed(196)
N          <- 1000
base       <- rnorm(N,0.167,0.05)  # Base is close to random probability
lapse      <- rbeta(N,3,5)       # Lapse is wide range - should not overlap base rate
#lapse      <- runif(N,0,.65)
threshold  <- rgamma(N,2,1)    # Threshold must be > 0 and can be > 1.
width      <- rgamma(N,2,1)    # Width must be > 0 and can be > 1.
# Varying intercept lapse
# Varying intercepts base
plot( NULL, xlim = c(-.5,2.5), ylim = c(0,1) ,
xlab = "Scaled stimulus strength", ylab = "Proportion correct response" )
abline (h=1/6, lty=2)
for ( i  in 1:N ) curve (
base[i] +
(1 - base[i] - lapse[i]) *
plogis(4.39*(	x - exp(threshold[i])	)	/ ( exp (width[i]) ) ),
from=-.5, to = 2.5, add = TRUE, col = col.alpha("black",0.1))
set.seed(196)
N          <- 1000
base       <- rnorm(N,0.167,0.05)  # Base is close to random probability
lapse      <- rbeta(N,3,5)       # Lapse is wide range - should not overlap base rate
lapse      <- runif(N,0,.65)
threshold  <- rgamma(N,2,2)    # Threshold must be > 0 and can be > 1.
width      <- rgamma(N,2,2)    # Width must be > 0 and can be > 1.
# Varying intercept lapse
# Varying intercepts base
plot( NULL, xlim = c(-.5,2.5), ylim = c(0,1) ,
xlab = "Scaled stimulus strength", ylab = "Proportion correct response" )
abline (h=1/6, lty=2)
for ( i  in 1:N ) curve (
base[i] +
(1 - base[i] - lapse[i]) *
plogis(4.39*(	x - exp(threshold[i])	)	/ ( exp (width[i]) ) ),
from=-.5, to = 2.5, add = TRUE, col = col.alpha("black",0.1))
set.seed(196)
N          <- 1000
base       <- rnorm(N,0.167,0.05)  # Base is close to random probability
lapse      <- rbeta(N,3,5)       # Lapse is wide range - should not overlap base rate
lapse      <- runif(N,0,.75)
threshold  <- rgamma(N,2,2)    # Threshold must be > 0 and can be > 1.
width      <- rgamma(N,2,2)    # Width must be > 0 and can be > 1.
# Varying intercept lapse
# Varying intercepts base
plot( NULL, xlim = c(-.5,2.5), ylim = c(0,1) ,
xlab = "Scaled stimulus strength", ylab = "Proportion correct response" )
abline (h=1/6, lty=2)
for ( i  in 1:N ) curve (
base[i] +
(1 - base[i] - lapse[i]) *
plogis(4.39*(	x - exp(threshold[i])	)	/ ( exp (width[i]) ) ),
from=-.5, to = 2.5, add = TRUE, col = col.alpha("black",0.1))
set.seed(196)
N          <- 1000
base       <- rnorm(N,0.167,0.05)  # Base is close to random probability
lapse      <- rbeta(N,3,5)       # Lapse is wide range - should not overlap base rate
lapse      <- runif(N,0,.75)
threshold  <- rgamma(N,2,2)    # Threshold must be > 0 and can be > 1.
width      <- rgamma(N,2,2)    # Width must be > 0 and can be > 1.
# Varying intercept lapse
# Varying intercepts base
plot( NULL, xlim = c(-.5,2.5), ylim = c(0,1) ,
xlab = "Scaled stimulus strength", ylab = "Proportion correct response" )
abline (h=1/6, lty=2)
for ( i  in 1:N ) curve (
base[i] +
(1 - base[i] - lapse[i]) *
plogis(4.39*(	x - threshold[i]	)	/ ( (width[i]) ) ),
from=-.5, to = 2.5, add = TRUE, col = col.alpha("black",0.1))
set.seed(196)
N          <- 1000
base       <- rnorm(N,0.167,0.05)  # Base is close to random probability
lapse      <- rbeta(N,3,5)       # Lapse is wide range - should not overlap base rate
#lapse      <- runif(N,0,.75)
threshold  <- rgamma(N,2,2)    # Threshold must be > 0 and can be > 1.
width      <- rgamma(N,2,2)    # Width must be > 0 and can be > 1.
# Varying intercept lapse
# Varying intercepts base
plot( NULL, xlim = c(-.5,2.5), ylim = c(0,1) ,
xlab = "Scaled stimulus strength", ylab = "Proportion correct response" )
abline (h=1/6, lty=2)
for ( i  in 1:N ) curve (
base[i] +
(1 - base[i] - lapse[i]) *
plogis(4.39*(	x - threshold[i]	)	/ ( (width[i]) ) ),
from=-.5, to = 2.5, add = TRUE, col = col.alpha("black",0.1))
hist(rgamma(1000,2,2))
hist(rgamma(1000,2,1.5))
hist(rgamma(1000,2,1))
hist(rgamma(1000,2,2))
param_trans <- function(x){
out = x*max(res$target)
return(out)}
mcmc_areas(res.psych.fit, pars=c("b_threshold_Intercept","b_width_Intercept"),
point_est = "median", prob = 0.8, prob_outer = 0.95,
transformations = param_trans) +
ggplot2::labs(title = "Posterior distributions", subtitle = "with medians and 80% intervals")
param_trans <- function(x){
out = x*max(res$target)
return(out)}
mcmc_areas(res.psych.fit, pars=c("b_threshold_Intercept","b_width_Intercept"),
point_est = "median", prob = 0.8, prob_outer = 0.95,
transformations = param_trans) +
ggplot2::labs(title = "Posterior distributions", subtitle = "with medians and 80% intervals")
hist(rbeta(1000,3,5))
hist(rbeta(1000,3,4))
hist(rbeta(1000,3,3))
hist(rbeta(1000,3,5))
hist(rbeta(1000,2,5))
hist(rbeta(1000,3,10))
hist(rbeta(1000,3,20))
hist(rbeta(1000,2,2))
hist(rbeta(1000,4,4))
hist(rbeta(1000,4,5))
hist(rbeta(1000,5,5))
hist(rbeta(1000,6,5))
hist(rbeta(1000,10,5))
hist(rbeta(1000,3,5))
hist(rbeta(1000,-1,5))
hist(rbeta(1000,100,5))
hist(rbeta(1000,10,10))
hist(rbeta(1000,1,1))
hist(rbeta(1000,100,100))
hist(rbeta(1000,10,10))
hist(rbeta(1000,5,5))
hist(rbeta(1000,10,10))
hist(rbeta(1000,7,10))
hist(rbeta(1000,6,10))
hist(rbeta(1000,7,10))
hist(rbeta(1000,7.5,10))
hist(rbeta(1000,7,10))
hist(rbeta(1000,7,10))
hist(rbeta(1000,10,10))
hist(rbeta(1000,10,10))
hist(rbeta(1000,10,10))
set.seed(196)
N          <- 1000
base       <- rnorm(N,0.167,0.05)  # Base is close to random probability
lapse      <- rbeta(N,10,10)       # Lapse is wide range - should not overlap base rate
#lapse      <- runif(N,0,.75)
threshold  <- rgamma(N,2,2)    # Threshold must be > 0 and can be > 1.
width      <- rgamma(N,2,2)    # Width must be > 0 and can be > 1.
# Varying intercept lapse
# Varying intercepts base
plot( NULL, xlim = c(-.5,2.5), ylim = c(0,1) ,
xlab = "Scaled stimulus strength", ylab = "Proportion correct response" )
abline (h=1/6, lty=2)
for ( i  in 1:N ) curve (
base[i] +
(1 - base[i] - lapse[i]) *
plogis(4.39*(	x - threshold[i]	)	/ ( (width[i]) ) ),
from=-.5, to = 2.5, add = TRUE, col = col.alpha("black",0.1))
set.seed(196)
N          <- 1000
base       <- rnorm(N,0.167,0.05)  # Base is close to random probability
lapse      <- rbeta(N,10,10)       # Lapse is wide range - should not overlap base rate
#lapse      <- runif(N,0,.75)
threshold  <- rgamma(N,2,2)    # Threshold must be > 0 and can be > 1.
width      <- rgamma(N,2,2)    # Width must be > 0 and can be > 1.
# Varying intercept lapse
# Varying intercepts base
plot( NULL, xlim = c(-.5,2.5), ylim = c(0,1) ,
xlab = "Scaled stimulus strength", ylab = "Proportion correct response" )
abline (h=1/6, lty=2)
for ( i  in 1:N ) curve (
base[i] +
(1 - base[i] - lapse[i]) *
plogis(4.39*(	x - threshold[i]	)	/ ( (width[i]) ) ),
from=-.5, to = 2.5, add = TRUE, col = col.alpha("black",0.1))
res.psych.formula <- bf(success ~
base +
(1 - base - lapse) *
inv_logit( 4.39*(	T - threshold	)	/  width  ),
base      ~ 1,# + (1|individual), # guess rate has a single value
lapse     ~ 1, #+ (1|individual), # lapse rate can be different for different chicks
threshold ~ 1, #+ (1|individual), # threshold changes with all effects
width     ~ 1, #+ (1|individual), # threshold-width changes with all effects
nl = TRUE)
res.psych.priors  <- c(
prior(normal(0.167,0.05),   nlpar = "base",        lb=0,ub= 0.25),
prior(beta(10,10),            nlpar = "lapse"             ,lb=0,ub= 0.74      ),
prior(gamma(2,2),           nlpar= 'threshold',  class = 'b'   ),
prior(gamma(2,2),           nlpar = 'width',     class = 'b'     ))
res.psych.fit  <- brm(res.psych.formula, data = res,
family = bernoulli("identity"), iter = 2500,
chains = 4, prior = res.psych.priors,
control = list(max_treedepth = 12,
adapt_delta=0.99999))
res.psych.fit  <- add_criterion(res.psych.fit, c("loo","waic"))
conditional_effects(res.psych.fit)
hist(rbeta(1000,20,20))
hist(rbeta(1000,15,15))
hist(rbeta(1000,10,15))
hist(rbeta(1000,15,15))
set.seed(196)
N          <- 1000
base       <- rnorm(N,0.167,0.05)  # Base is close to random probability
lapse      <- rbeta(N,15,15)       # Lapse is wide range - should not overlap base rate
#lapse      <- runif(N,0,.75)
threshold  <- rgamma(N,2,2)    # Threshold must be > 0 and can be > 1.
width      <- rgamma(N,2,2)    # Width must be > 0 and can be > 1.
# Varying intercept lapse
# Varying intercepts base
plot( NULL, xlim = c(-.5,2.5), ylim = c(0,0.8) ,
xlab = "Scaled stimulus strength", ylab = "Proportion correct response" )
abline (h=1/6, lty=2)
for ( i  in 1:N ) curve (
base[i] +
(1 - base[i] - lapse[i]) *
plogis(4.39*(	x - threshold[i]	)	/ ( (width[i]) ) ),
from=-.5, to = 2.5, add = TRUE, col = col.alpha("black",0.1))
set.seed(196)
N          <- 1000
base       <- rnorm(N,0.167,0.05)  # Base is close to random probability
lapse      <- rbeta(N,15,15)       # Lapse is wide range - should not overlap base rate
#lapse      <- runif(N,0,.75)
threshold  <- rgamma(N,2,2)    # Threshold must be > 0 and can be > 1.
width      <- rgamma(N,2,2)    # Width must be > 0 and can be > 1.
# Varying intercept lapse
# Varying intercepts base
plot( NULL, xlim = c(-.5,2.5), ylim = c(0,0.8) ,
xlab = "Scaled stimulus strength", ylab = "Proportion correct response" )
abline (h=1/6, lty=2)
for ( i  in 1:N ) curve (
base[i] +
(1 - base[i] - lapse[i]) *
plogis(4.39*(	x - threshold[i]	)	/ ( (width[i]) ) ),
from=-.5, to = 2.5, add = TRUE, col = col.alpha("black",0.1))
plot( NULL, xlim = c(-.5,2.5), ylim = c(0.1,0.8) ,
xlab = "Scaled stimulus strength", ylab = "Proportion correct response" )
abline (h=1/6, lty=2)
for ( i  in 1:N ) curve (
base[i] +
(1 - base[i] - lapse[i]) *
plogis(4.39*(	x - threshold[i]	)	/ ( (width[i]) ) ),
from=-.5, to = 2.5, add = TRUE, col = col.alpha("black",0.1))
